# 基本的な使い方

 - 入力ディレクトリと出力ディレクトリを作成し、入力ディレクトリに入力ファイルを入れる

 - コマンド「sml main.sml 入力ディレクトリ名 出力ディレクトリ名 書き換え推論規則ファイル名 暗黙の条件の導出規則ファイル名」を実行 (ダブルクォート等は不要)

# 規則の適用について

## 基本的な規則の記述の仕方

 - 推論規則同士は改行により区切ります。

 - 空の行を入れてもOKです。

 - モデルでは変数名は2文字以上である必要がありますが、推論規則上では何文字でもOKです。

 - 推論規則の推論前と推論後の間の区切りとして"@->@"を使用します。

 - 書き換え前後の式や型制約それぞれの中だけでコメントは有効になります。ただし行頭の//は行全部をコメン卜アウ卜します。

 - (重要) 規則は上から順番にマッチングが試行されます。上によりマッチしやすい規則を書いてしまうと下の規則がずっと実行されなくなってしまうため注意が必要です。
   例：「x + x + y @->@ 2 * x + y」より後に「x + x + x + y @->@ 3 * x + y」を書くと、後者は決して実行されない

## 型制約

 - 型の制約を入れる場合はルール後に"@TYPES@"と書き、さらにその後に型制約をB言語の条件式の形で記述します。

 - @TYPES@以降がないのときは、型制約なしとして扱われます。

 - xが「何らかの集合」であることは x : POW(x) と記述できます。
 
 - 必ずしも登場する全ての変数の型を指定する必要はありません。

## 可換・結合的な演算について

 - 可換・結合的な演算は一部のオペランドへの適用も可能ですが、書き換えない項があるときと無いときの2パターンの書き換え規則を書く必要がある場合があります。
   例:
   x + (-x)     @->@ 0           // ← a + (-a) + b を b + 0 に書き換えることはできない
   x + (-x) + y @->@ y           // ← a + (-a)     を 0     に書き換えることはできない（a + (-a) + b + c などには適用可能）
   ただし、暗黙の条件の導出規則は自動で「& [残りの項]」を入れた場合の規則も追加するため後者の規則は書かなくてOKです。

 - 可換・結合的な演算について、マッチングの途中で列挙される部分式のマッチング候補を減らし、効率化を図るため、「制限付き変数」を利用することができます。
   制限付き変数はその階層の可換演算において複数の被演算子にマッチしません。
   制限付き変数は、変数の末尾に "_" を付けることで指定できます。
   例えば、規則 x + x + y @->@ 2 * x を a + b + a + b + c に適用しようとすると、x に対して a, b, a + b がマッチするが、規則 x_ + x_ + y @->@ 2 * x_ を用いると、x に a + b がマッチせず、書き換えを効率化できます。

 - 2 * a + 3 * a を 5 * a に書き換えるような場合、リテラルとそれ以外を区別する必要性が出てきます。
   そのような場合には、リテラルのみにマッチする規則上の変数である「リテラル変数」が利用できます。
   リテラル変数は末尾に "_lit" を付けることで指定できます。
   例えば、n_lit * x + m_lit * x @->@ (n_lit + m_lit) * x は上の書き換えを実現します。
 
 - 規則上の変数が型集合にのみマッチするよう「型集合変数」を利用することができます。
   型集合変数は、変数の末尾に "_type" を付けることで指定できます。
   この型集合には INTEGER 等の組み込みのものに加え、ユーザが SETS で宣言したものも含まれます。

2023/3/27 最終更新
